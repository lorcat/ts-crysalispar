#!/usr/bin/env python
# -*- coding:utf-8 -*-


# ############################################################################
#  license :
# ============================================================================
#
#  File :        CrysalisParFileWatchdog.py
#
#  Project :     Crysalis par file copy
#
# This file is part of Tango device class.
# 
# Tango is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
# 
# Tango is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with Tango.  If not, see <http://www.gnu.org/licenses/>.
# 
#
#  $Author :      konstantin.glazyrin$
#
#  $Revision :    $
#
#  $Date :        $
#
#  $HeadUrl :     $
# ============================================================================
#            This file is generated by POGO
#     (Program Obviously used to Generate tango Object)
# ############################################################################

__all__ = ["CrysalisParFileWatchdog", "CrysalisParFileWatchdogClass", "main"]

__docformat__ = 'restructuredtext'

import json

import PyTango
import sys

# Add additional import
# ----- PROTECTED REGION ID(CrysalisParFileWatchdog.additionnal_import) ENABLED START -----#
try:
    from tango import DeviceProxy, DevState, DevFailed
except ImportError:
    from PyTango import DeviceProxy, DevState, DevFailed

import os
import sys
import re
import threading
import queue
import copy
import time

from watchdog.events import PatternMatchingEventHandler, FileSystemEvent
from watchdog.observers import Observer


class Storage:
    """
    Local class controlling storage and inter-thread communication
    """
    K_CALIBRATION = "Calibration"
    K_LASTFILE = "LastFile"
    K_LASTFILETIMESTAMP = "LastFileTimestamp"
    K_CALFILELINES = "CalibrationFileLines"

    K_WATCHPATH = "Paths"
    K_WATCHPATTERN = "CalibrationPattern"

    PAR_PATTERN = "*.par"

    STOP_MSG = "stop"

    # delay between the last modification time and current timestamp
    OK_TIMEDIFFERENCE = 3.0

    # PAR file lock extension
    EXT_PARFILELOCK = ".lock"

    # errors
    TMPL_PROPERRORS = {K_WATCHPATH: False, K_WATCHPATTERN: False}

    # storage template
    TMPL_STORAGE = {
        K_CALIBRATION: "", K_LASTFILE: "", K_CALFILELINES: [],
        K_LASTFILETIMESTAMP: None,
        K_WATCHPATH: None,
        K_WATCHPATTERN: None,
    }

    def __init__(self):
        self._storage = copy.deepcopy(self.TMPL_STORAGE)
        self._lock_storage = threading.Lock()

        self._errors = copy.deepcopy(self.TMPL_PROPERRORS)
        self._errormsg = []
        self._lock_errors = threading.Lock()

        # container for files information - fullpath + timestamp
        self._files = {}
        self._lock_files = threading.Lock()

    @property
    def storage(self):
        """
        Returns a copy for the storage
        :return:
        """
        res = None
        with self._lock_storage:
            res = copy.deepcopy(self._storage)
        return res

    @property
    def parfiles(self):
        """
        Returns a copy of the current state for the files
        :return:
        """
        res = None
        with self._lock_files:
            res = copy.deepcopy(self._files)
        return res

    @property
    def errors(self):
        res = None
        with self._lock_errors:
            res = copy.deepcopy(self._errors)
        return res

    @property
    def calibration_file(self):
        """
        Returns last calibration file
        :return: str() - e.g. Empty, Au, etc
        """
        k = self.K_CALIBRATION
        res = self.get_storage_by_key(k)
        return res

    @property
    def calibration_lines(self):
        """
        Returns last calibration file
        :return: str() - e.g. Empty, Au, etc
        """
        k = self.K_CALFILELINES
        res = self.get_storage_by_key(k)
        return res

    @property
    def watchpaths(self):
        """
        Returns watch path
        :return: str() - e.g. Empty, Au, etc
        """
        k = self.K_WATCHPATH
        res = self.get_storage_by_key(k)
        return res

    @property
    def watchpattern(self):
        """
        Returns watch pattern
        :return: str() - e.g. Empty, Au, etc
        """
        k = self.K_WATCHPATTERN
        res = self.get_storage_by_key(k)
        return res

    @property
    def lastfile_timestamp(self):
        """
        Returns timestamp for the last processed file
        :return: str() - e.g. Empty, Au, etc
        """
        k = self.K_LASTFILETIMESTAMP
        res = self.get_storage_by_key(k)
        return res

    @property
    def lastfile(self):
        """
        Returns last name of the last processed file
        :return: str() - e.g. Empty, Au, etc
        """
        k = self.K_LASTFILE
        res = self.get_storage_by_key(k)
        return res

    @property
    def errormsgs(self):
        """
        Returns error messages accumulated through the startup process
        :return:
        """
        res = []
        with self._lock_errors:
            res = copy.deepcopy(self._errormsg)
        return res

    def get_storage_by_key(self, k):
        """
        Returns a storage element by key in a thread safe manner
        :param k: str()
        :return:
        """
        res = None

        # return only positions making sense
        with self._lock_storage:
            if k in self._storage.keys():
                tdata = copy.deepcopy(self._storage)
            res = tdata[k]
        return res

    def set_storage_by_key(self, k, v):
        """
        Sets a storage value by key in a thread safe manner
        :param k:
        :param v:
        :return:
        """
        with self._lock_storage:
            tv = None

            if isinstance(v, tuple) or isinstance(v, list) or isinstance(v, dict) or isinstance(v, set):
                tv = copy.deepcopy(v)
            else:
                tv = v

            if k in self._storage.keys():
                self._storage[k] = tv
            else:
                self._storage.setdefault(k, tv)

    def set_calibration_file(self, v):
        """
        Sets filename for calibration file
        :param v:
        :return:
        """
        k = self.K_CALIBRATION
        self.set_storage_by_key(k, v)

    def set_calibration_lines(self, v):
        """
        Copies calibration lines into storage
        :param v:
        :return:
        """
        k = self.K_CALFILELINES
        self.set_storage_by_key(k, v)

    def set_error_by_key(self, k, v):
        """
        Sets the error state for specific component
        :param k:
        :param v:
        :return:
        """
        with self._lock_errors:
            if k in self._errors.keys():
                self._errors[k] = v
            else:
                self._errors.setdefault(k, v)

    def set_watchpath_error(self, v):
        """
        Sets watch path error
        :param v:
        :return:
        """
        k = self.K_WATCHPATH
        self.set_error_by_key(k, v)

    def set_watchpattern_error(self, v):
        """
        Sets watch path error
        :param v:
        :return:
        """
        k = self.K_WATCHPATTERN
        self.set_error_by_key(k, v)

    def set_watchpath(self, v):
        """
        Sets watch path - tuple or list
        :param v:
        :return:
        """
        k = self.K_WATCHPATH
        self.set_storage_by_key(k, v)

    def set_watchpattern(self, v):
        """
        Sets watch pattern mathing calibration file
        :param v:
        :return:
        """
        k = self.K_WATCHPATTERN
        self.set_storage_by_key(k, v)

    def add_errormsg(self, v):
        """
        Adds an error message to the list
        :param v:
        :return:
        """
        with self._lock_errors:
            self._errormsg.append(str(v))

    def has_errors(self):
        """
        Returns true if errors were present on initialization of the Tango Server
        :return:
        """
        te = self.errors

        res = False
        if True in self.errors.values():
            res = True

        return res

    def add_filerecord(self, filename: str):
        """
        Adds a record of a new par file or par file
        :param filename:
        :return:
        """
        ts = time.time()
        with self._lock_files:
            if filename in self._files:
                self._files[filename] = ts
            else:
                self._files.setdefault(filename, ts)

    def remove_filerecord(self, filename: str):
        """
        Removes the file record from the dictionary
        :param filename:
        :return:
        """
        with self._lock_files:
            if filename in self._files:
                del self._files[filename]


class ParEventHandler(PatternMatchingEventHandler):
    """
    Class adding
    """

    def __init__(self, storage: Storage, *args, **kwargs):
        PatternMatchingEventHandler.__init__(self, *args, **kwargs)

        self.storage = storage

    def on_created(self, event):
        """
        Process created event - add the info as a timestamp
        :param event:
        :return:
        """
        self.report_change(event)

    def on_modified(self, event):
        """
        Process modified evend - add info as a timestamp
        :param event:
        :return:
        """
        self.report_change(event)

    def report_change(self, event):
        """
        Report the changes into the common storage object
        :param event:
        :return:
        """
        if isinstance(event, FileSystemEvent):
            fpath =os.path.abspath(event.src_path)
            fpath = fpath.replace("\\", "/")

            # avoiding par files made by crysalis - they should not be added
            pcracker = re.compile(".*cracker[^/]*\.par", re.I)
            mcracker = pcracker.match(fpath)

            if mcracker is None:
                self.storage.add_filerecord(fpath)
                print("Adding a record for ({})".format(fpath))


class ParWatchdog(threading.Thread):
    """
    Class thread polling the data and responsible for clean watchdog shutdown
    """
    POLLING_DELAY = 0.5

    def __init__(self, qparfiles: queue.Queue, storage: Storage):
        threading.Thread.__init__(self)
        self.setDaemon(True)

        self.qparfiles = qparfiles
        self.storage = storage

        # list with observers + event handlers
        self._observers = []
        self._evh = ParEventHandler(self.storage, patterns=[self.storage.PAR_PATTERN],
                                    ignore_directories=True)

        # stop signal handling
        self._qstop = queue.Queue()

    def stop(self):
        """
        Sets stop signal for the thread
        :return:
        """
        self._qstop.put(self.storage.STOP_MSG)

    def run(self):
        """
        Starts the thread watching directories and cleans up on clean exit
        :return:
        """
        paths = self.storage.watchpaths

        print("Starting {} as {}".format(self.__class__.__name__, threading.currentThread().getName()))

        for path in paths:
            o = Observer()
            o.schedule(self._evh, path, recursive=True)

            print("Adding an observer ({}) to path ({})".format(o, path))
            self._observers.append(o)
            o.start()

        try:
            while True:
                time.sleep(self.POLLING_DELAY)

                try:
                    self._qstop.get(block=False)
                    self._qstop.task_done()
                    raise ValueError("Time to stop")
                except queue.Empty:
                    pass
        except ValueError as e:
            pass
        finally:
            for o in self._observers:
                o.stop()
                o.join()

        print("Stopping {} as {}".format(self.__class__.__name__, threading.currentThread().getName()))


class ParTester(threading.Thread):
    """
    Class checking the status of the par files.
    If the par file is in the list of recently modified and its last modification time is larger than predefined,
    it is set for processing.
    """
    POLLING_DELAY = 0.5

    def __init__(self, qparfiles: queue.Queue, storage: Storage):
        threading.Thread.__init__(self)
        self.setDaemon(True)

        self.qparfiles = qparfiles
        self.storage = storage

        self._qstop = queue.Queue()

    def stop(self):
        """
        Stops the thread
        :return:
        """
        self._qstop.put(self.storage.STOP_MSG)

    def run(self) -> None:
        """
        Processes the storage with files
        :return:
        """

        print("Starting {} as {}".format(self.__class__.__name__, threading.currentThread().getName()))

        try:
            while True:

                self.workload()

                time.sleep(self.POLLING_DELAY)

                try:
                    self._qstop.get(block=False)
                    self._qstop.task_done()
                    raise IOError("Time to stop")
                except queue.Empty:
                    pass
        except IOError as e:
            pass

        print("Stopping {} as {}".format(self.__class__.__name__, threading.currentThread().getName()))

    def workload(self):
        """
        The actual workload for file processing
        :return:
        """
        # get the list of files
        files = self.storage.parfiles

        if not isinstance(files, dict):
            return

        if len(files.keys()) == 0:
            return

        # we will mark files for processing only if the dT is sufficient and there is no lock file present
        tsnow = time.time()

        for (fn, ts) in files.items():
            if tsnow - ts > self.storage.OK_TIMEDIFFERENCE:

                fn_lock = "{}{}".format(fn, self.storage.EXT_PARFILELOCK)

                if not os.path.exists(fn_lock):
                    tfn = fn.replace("\\", "/")
                    self.qparfiles.put(tfn)
                    print("File ({}) is labeled for processing (dt == {:6.2f} s)".format(tfn, tsnow - ts))

                # removing the file from the list of files
                self.storage.remove_filerecord(fn)


class ParProcessor(threading.Thread):
    """
    Class processing the queue with par files.
    The modified calibration file is reprocessed.
    In order to avoid excessive reprocessing of the experimental file - a lock file is created in the same folder.
    """
    POLLING_DELAY = 0.5

    # patterns to match
    PATT_EXPCOMPOUNDNAME = re.compile(b"^\s*EXPERIMENT\s+COMPOUNDNAME.*$", re.I)
    PATT_FILECHIP = re.compile(b"^\s*FILE\s+CHIP.*$", re.I)

    def __init__(self, qparfiles: queue.Queue, storage: Storage, parent):
        threading.Thread.__init__(self)
        self.setDaemon(True)

        self.qparfiles = qparfiles
        self.storage = storage
        self.parent = parent

        self._qstop = queue.Queue()

    def stop(self):
        """
        Stops the thread
        :return:
        """
        self._qstop.put(self.storage.STOP_MSG)

    def run(self):
        """
        Processing the data
        :return:
        """

        print("Starting {} as {}".format(self.__class__.__name__, threading.currentThread().getName()))

        try:
            while True:

                self.workload()

                time.sleep(self.POLLING_DELAY)

                try:
                    self._qstop.get(block=False)
                    self._qstop.task_done()
                    raise IOError("Time to stop")
                except queue.Empty:
                    pass
        except IOError as e:
            pass

        print("Stopping {} as {}".format(self.__class__.__name__, threading.currentThread().getName()))

    def workload(self):
        """
        Actual workload for data processing - calibration files treated one way, data files are treated the other way
        :return:
        """
        try:
            parfile = self.qparfiles.get(block=False)
            self.qparfiles.task_done()
        except queue.Empty:
            return

        tp = ".*/{}[^\/]*\.par$".format(self.storage.watchpattern)
        pcalibrant = re.compile(tp, re.I)

        if os.path.isfile(parfile):
            m = pcalibrant.match(parfile)
            if m:
                self.process_calibration(parfile)
            else:
                self.process_experiment(parfile)

    def process_calibration(self, parfile: str):
        """
        Processes the calibration par file, extracts useful data
        :param parfile:
        :return:
        """
        print("Processing calibration: ({})".format(parfile))

        # read the file - load it into memory
        try:
            with open(parfile, "rb") as fh:
                tlines = fh.readlines()

            # fill the storage with this data
            self.storage.set_calibration_file(parfile)
            self.storage.set_calibration_lines(tlines)
            self.report("Calibration file ({}) has been loaded".format(parfile))
        except (IOError, OSError) as e:
            self.report("Error with file reading, skipping the file:\n{};".format(parfile))

    def process_experiment(self, parfile: str):
        """
        Processes the experiment par file, replaces useful data if it is available from calibration
        :param parfile:
        :return:
        """
        print("Processing experiment: ({})".format(parfile))

        # get calibration file & lines
        cfn = self.storage.calibration_file
        clines = self.storage.calibration_lines

        # clean calibration
        if cfn is None or len(cfn) == 0:
            self.report("Error: No calibration file present;\nSkipping ({});".format(os.path.basename(parfile)))
            return

        if not os.path.isfile(cfn) or len(clines) == 0:
            self.storage.set_calibration_file("")
            self.storage.set_calibration_lines([])

            self.report("Error: calibration file is invalid:\n{};".format(cfn))
            return

        pexpmatch = {}
        tplist = (self.PATT_EXPCOMPOUNDNAME, self.PATT_FILECHIP,)
        try:
            with open(parfile, "rb") as fh:
                exp_lines = fh.readlines()

            # find experimental lines with experiment relevant information
            for line in exp_lines:

                for p in tplist:
                    m = p.match(line)

                    if m is not None:
                        pexpmatch.setdefault(p, line)

            # make the lock file a copy of the initial par file just in case
            fn_lock = "{}{}".format(parfile, self.storage.EXT_PARFILELOCK)
            with open(fn_lock, "wb") as fh:
                fh.writelines(exp_lines)

            if len(pexpmatch.keys()) != len(tplist):
                raise ValueError("Could not extract relevant file keys")

            # go through the lines and modify the calibration file accordingly
            for (i, line) in enumerate(clines):
                for p in tplist:
                    if p.match(line):
                        clines[i] = pexpmatch[p]

            # write modified experimental file
            with open(parfile, "wb") as fh:
                fh.writelines(clines)

            self.report("Processing successful:\n".format(parfile))
        except (IOError, OSError, ValueError) as e:
            self.report("Error with file processing:\n{};\n{}".format(parfile, e))

    def report(self, msg):
        """
        Reports processing error to the status and to the stdio
        :param msg:
        :return:
        """
        print(msg)

        try:
            self.parent.ts_set_status(msg)
        except AttributeError:
            pass


# ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.additionnal_import

# Device States Description
# No states for this device

class CrysalisParFileWatchdog(PyTango.Device_4Impl):
    """Tango server updating the most current information/geometry into from a reference .par file into new mesured .par files.
    It installes and uses python watchdog module for taking care of the new files."""

    # -------- Add you global variables here --------------------------
    # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.global_variables) ENABLED START -----#

    # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.global_variables

    def __init__(self, cl, name):
        PyTango.Device_4Impl.__init__(self, cl, name)
        self.debug_stream("In __init__()")
        CrysalisParFileWatchdog.init_device(self)
        # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.__init__) ENABLED START -----#

        # locks for multithreading communication for state and status

        # set the inital state and status
        self.ts_set_state(DevState.ON)
        self.ts_set_status("Calibration Path: {}\nCalibration File Pattern: {}".format(self.WatchPath,
                                                                                       self.CalibFilePattern))

        # prepare threads
        # queue for passing info about the files
        self.qparfiles = queue.Queue()

        # thread with watchdog
        self._th_watchdog = ParWatchdog(self.qparfiles, self.storage)
        self._th_watchdog.start()

        # thread with par file checking
        self._th_testpar = ParTester(self.qparfiles, self.storage)
        self._th_testpar.start()

        # thread with par file processing
        self._th_processpar = ParProcessor(self.qparfiles, self.storage, self)
        self._th_processpar.start()

        # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.__init__

    def delete_device(self):
        self.debug_stream("In delete_device()")
        # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.delete_device) ENABLED START -----#

        for th in (self._th_watchdog, self._th_testpar, self._th_processpar):
            if th is not None and issubclass(th.__class__, threading.Thread) and th.is_alive():
                # print("Stopping {}".format(th))
                th.stop()
                th.join()

        # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.delete_device

    def init_device(self):
        self.debug_stream("In init_device()")
        self.get_device_properties(self.get_device_class())
        self.attr_LastCalibrationPar_read = ""
        self.attr_LastProcessedPar_read = ""
        self.attr_LastProcessedTS_read = ""
        # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.init_device) ENABLED START -----#

        # check properties for errors
        # WatchPath should be a valid string and all paths should exist
        # CalibFilePattern should have decent length

        self._lock_state = threading.Lock()
        self._lock_status = threading.Lock()

        # initialize storage
        self.storage = Storage()

        # check paths
        try:
            tpaths = json.loads(self.WatchPath)

            if not isinstance(tpaths, tuple) and not isinstance(tpaths, list):
                raise ValueError("paths should be in a form of an array; ({});".format(self.WatchPath))
            else:
                paths = []
                for p in tpaths:
                    if os.path.exists(p) and os.path.isdir(p):
                        paths.append(p)

                if len(paths) == 0:
                    raise ValueError("there are no valid folders; ({});".format(self.WatchPath))

                # copy paths to the storage
                self.storage.set_watchpath(paths)
        except json.JSONDecodeError as e:
            self.storage.set_watchpath_error(True)
            self.storage.add_errormsg("Path string is not a valid JSON string: ({})".format(self.WatchPath))
        except ValueError as e:
            self.storage.set_watchpath_error(True)
            self.storage.add_errormsg("Path is not valid: ({})".format(e))

        # check pattern
        try:
            tp = str(self.CalibFilePattern).strip()

            trp = re.compile("[^a-z0-9\-_]+", re.I)
            tp = re.sub(trp, "", tp)

            if len(tp) == 0:
                raise ValueError("length of pattern with reduction of special characters is 0")

            self.storage.set_watchpattern(tp)
        except ValueError as e:
            self.storage.set_watchpattern_error(True)
            self.storage.add_errormsg("Pattern is not valid: ({})".format(e))

        # make decisions based on error state
        if self.storage.has_errors():
            self.ts_set_state(DevState.FAULT)

            msg = "\n".join(self.storage.errormsgs)
            self.ts_set_status(msg)
            print(msg)
        else:
            self.ts_set_state(DevState.ON)
            print("Initialization is successful:\nWatch paths: {}\nCalibration file pattern: {}\n".format(
                self.WatchPath, self.CalibFilePattern))

        # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.init_device

    def always_executed_hook(self):
        self.debug_stream("In always_excuted_hook()")
        # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.always_executed_hook) ENABLED START -----#

        # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.always_executed_hook

    # -------------------------------------------------------------------------
    #    CrysalisParFileWatchdog read/write attribute methods
    # -------------------------------------------------------------------------

    def read_LastCalibrationPar(self, attr):
        self.debug_stream("In read_LastCalibrationPar()")
        # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.LastCalibrationPar_read) ENABLED START -----#
        attr.set_value(self.attr_LastCalibrationPar_read)

        # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.LastCalibrationPar_read

    def read_LastProcessedPar(self, attr):
        self.debug_stream("In read_LastProcessedPar()")
        # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.LastProcessedPar_read) ENABLED START -----#
        attr.set_value(self.attr_LastProcessedPar_read)

        # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.LastProcessedPar_read

    def read_LastProcessedTS(self, attr):
        self.debug_stream("In read_LastProcessedTS()")
        # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.LastProcessedTS_read) ENABLED START -----#
        attr.set_value(self.attr_LastProcessedTS_read)

        # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.LastProcessedTS_read

    def read_attr_hardware(self, data):
        self.debug_stream("In read_attr_hardware()")
        # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.read_attr_hardware) ENABLED START -----#

        # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.read_attr_hardware

    # -------------------------------------------------------------------------
    #    CrysalisParFileWatchdog command methods
    # -------------------------------------------------------------------------

    # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.programmer_methods) ENABLED START -----#
    def ts_set_state(self, v):
        """
        Thread safe change of the state
        :return:
        """
        with self._lock_state:
            self.set_state(v)

    def ts_get_state(self):
        """
        Thread safe change of the state
        :return:
        """
        res = DevState.FAULT
        with self._lock_state:
            res = self.state()
        return res

    def ts_set_status(self, v):
        """
        Thread safe change of the status message
        :return:
        """

        msg = "{}\n{}\n{}".format(self.CalibFilePattern, self.WatchPath, v)

        with self._lock_status:
            self.set_status(msg)
    # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.programmer_methods


class CrysalisParFileWatchdogClass(PyTango.DeviceClass):
    # -------- Add you global class variables here --------------------------
    # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.global_class_variables) ENABLED START -----#

    # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.global_class_variables

    #    Class Properties
    class_property_list = {
    }

    #    Device Properties
    device_property_list = {
        'CalibFilePattern':
            [PyTango.DevString,
             "Calibration file pattern. First symbols of the calibration file name.\nSpecial symbols will be removed, only letters and digits will be used to build a real pattern.",
             ["enst"]],
        'WatchPath':
            [PyTango.DevString,
             "System path used for watching for new calibrations and experimental paths.\nUse a JSON string to provide multiple paths as an array.",
             ["[\"./\"]"]],
    }

    #    Command definitions
    cmd_list = {
    }

    #    Attribute definitions
    attr_list = {
        'LastCalibrationPar':
            [[PyTango.DevString,
              PyTango.SCALAR,
              PyTango.READ],
             {
                 'description': "Last calibration file read by the Tango Server - full path.",
             }],
        'LastProcessedPar':
            [[PyTango.DevString,
              PyTango.SCALAR,
              PyTango.READ]],
        'LastProcessedTS':
            [[PyTango.DevString,
              PyTango.SCALAR,
              PyTango.READ],
             {
                 'description': "Timestamp of the last processed file.",
             }],
    }


def main():
    try:
        py = PyTango.Util(sys.argv)
        py.add_class(CrysalisParFileWatchdogClass, CrysalisParFileWatchdog, 'CrysalisParFileWatchdog')
        # ----- PROTECTED REGION ID(CrysalisParFileWatchdog.add_classes) ENABLED START -----#

        # ----- PROTECTED REGION END -----#	//	CrysalisParFileWatchdog.add_classes

        U = PyTango.Util.instance()
        U.server_init()
        U.server_run()

    except PyTango.DevFailed as e:
        print('-------> Received a DevFailed exception:', e)
    except Exception as e:
        print('-------> An unforeseen exception occured....', e)


if __name__ == '__main__':
    main()
